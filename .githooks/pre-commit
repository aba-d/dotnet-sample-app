#!/bin/sh
# Combined Pre-commit Hook with Test Mode and Multi-Build Tool Support
# Supports both testing and production enforcement
# Usage: 
#   Production: normal git commit
#   Test mode: TEST_MODE=true git commit
#   Dry run: DRY_RUN=true git commit
#   Debug: DEBUG_MODE=true git commit
 
# =============================================================================
# TERMINAL COLORS CONFIGURATION
# =============================================================================
 
# Color codes for terminal output
if [ -t 1 ]; then
    # Colors (only if terminal supports it)
    RED='\033[0;31m'
    GREEN='\033[0;32m'
    YELLOW='\033[0;33m'
    BLUE='\033[0;34m'
    PURPLE='\033[0;35m'
    CYAN='\033[0;36m'
    WHITE='\033[0;37m'
    BOLD='\033[1m'
    DIM='\033[2m'
    UNDERLINE='\033[4m'
    RESET='\033[0m'
    
    # Background colors
    BG_RED='\033[41m'
    BG_GREEN='\033[42m'
    BG_YELLOW='\033[43m'
    BG_BLUE='\033[44m'
    BG_PURPLE='\033[45m'
    BG_CYAN='\033[46m'
else
    # No colors if not in terminal
    RED=''
    GREEN=''
    YELLOW=''
    BLUE=''
    PURPLE=''
    CYAN=''
    WHITE=''
    BOLD=''
    DIM=''
    UNDERLINE=''
    RESET=''
    BG_RED=''
    BG_GREEN=''
    BG_YELLOW=''
    BG_BLUE=''
    BG_PURPLE=''
    BG_CYAN=''
fi
 
# =============================================================================
# CONFIGURATION AND MODE DETECTION
# =============================================================================
 
# Detect execution mode
TEST_MODE=${TEST_MODE:-false}
DRY_RUN=${DRY_RUN:-false}
DEBUG_MODE=${DEBUG_MODE:-false}
 
# Mode-specific configuration with colors
if [ "$TEST_MODE" = "true" ]; then
    printf "${CYAN}${BOLD}üß™ [TEST MODE]${RESET} ${CYAN}Pre-commit validation (non-blocking)${RESET}\n"
    FAIL_ON_ERROR=false
    VERBOSE=true
elif [ "$DRY_RUN" = "true" ]; then
    printf "${PURPLE}${BOLD}üîç [DRY RUN]${RESET} ${PURPLE}Pre-commit validation (simulation only)${RESET}\n"
    FAIL_ON_ERROR=false
    VERBOSE=true
else
    printf "${BLUE}${BOLD}[INFO]${RESET} ${WHITE}Running centralized DevOps pre-commit checks...${RESET}\n"
    FAIL_ON_ERROR=true
    VERBOSE=${DEBUG_MODE}
fi
 
printf "${DIM}[MODE]${RESET} Test: ${BOLD}$TEST_MODE${RESET} | Dry Run: ${BOLD}$DRY_RUN${RESET} | Debug: ${BOLD}$DEBUG_MODE${RESET}\n"
 
# =============================================================================
# ENHANCED UTILITY FUNCTIONS WITH COLORS
# =============================================================================
 
# Colorized logging functions
log_info() {
    printf "${BLUE}${BOLD}[INFO]${RESET} ${WHITE}$1${RESET}\n"
}
 
log_warning() {
    printf "${YELLOW}${BOLD}‚ö†Ô∏è  [WARNING]${RESET} ${YELLOW}$1${RESET}\n"
}
 
log_error() {
    local message="$1"
    printf "${RED}${BOLD}‚ùå [ERROR]${RESET} ${RED}$message${RESET}\n"
    
    if [ "$FAIL_ON_ERROR" = "true" ]; then
        exit 1
    else
        printf "${CYAN}${BOLD}üß™ [TEST MODE]${RESET} ${CYAN}Would fail in production mode${RESET}\n"
        return 1
    fi
}
 
log_success() {
    printf "${GREEN}${BOLD}‚úÖ [SUCCESS]${RESET} ${GREEN}$1${RESET}\n"
}
 
log_debug() {
    if [ "$VERBOSE" = "true" ]; then
        printf "${DIM}[DEBUG]${RESET} ${DIM}$1${RESET}\n"
    fi
}
 
# Special colored output functions
log_build_tool() {
    printf "${CYAN}${BOLD}üîß Build Tool:${RESET} ${CYAN}$1${RESET}\n"
}
 
log_branch() {
    printf "${PURPLE}${BOLD}[BRANCH]${RESET} Current branch: ${PURPLE}${BOLD}$1${RESET}\n"
}
 
log_project() {
    printf "${BLUE}${BOLD}[INFO]${RESET} Project: ${BOLD}$1${RESET} | Type: ${CYAN}${BOLD}$2${RESET}\n"
}
 
log_security_scan() {
    printf "${YELLOW}${BOLD}üîç [SECURITY]${RESET} ${YELLOW}$1${RESET}\n"
}
 
# =============================================================================
# ORGANIZATIONAL POLICIES (MODE-AWARE)
# =============================================================================
 
# Security settings (stricter in production)
if [ "$TEST_MODE" = "true" ]; then
    SECURITY_PATTERNS="password|secret|token"  # Reduced for testing
    SECURITY_MAX_FILE_SIZE="10M"               # More lenient
    SECURITY_FAIL_ON_SECRETS=false             # Warning only in test
else
    # SECURITY_PATTERNS="password|secret|token|key|credential|api_key|auth_token"
    SECURITY_PATTERNS="password\s*[=:]\s*[\"']|secret\s*[=:]\s*[\"']|(?<!sonar\.)token\s*[=:]\s*[\"']|api_key\s*[=:]\s*[\"']|auth_token\s*[=:]\s*[\"']"
    SECURITY_MAX_FILE_SIZE="5M"
    SECURITY_FAIL_ON_SECRETS=true
fi
 
# Build tool preferences
PREFERRED_BUILD_TOOL=${PREFERRED_BUILD_TOOL:-"auto"}
 
# =============================================================================
# PROJECT DETECTION AND VALIDATION
# =============================================================================
 
log_info "Detecting project configuration..."
 
# Get current branch
CURRENT_BRANCH=$(git branch --show-current 2>/dev/null || echo "unknown")
log_branch "$CURRENT_BRANCH"
 
# Auto-detect project type
DETECTED_TYPE=""
if [ -f "package.json" ]; then
    DETECTED_TYPE="nodejs"
elif find . -maxdepth 2 -name "*.csproj" -o -name "*.sln" | grep -q .; then
    DETECTED_TYPE="dotnet"
elif [ -f "pom.xml" ] || [ -f "build.gradle" ] || [ -f "build.gradle.kts" ] || [ -f "build.xml" ] || find . -maxdepth 2 -name "*.java" | grep -q .; then
    DETECTED_TYPE="java"
elif [ -f "requirements.txt" ] || [ -f "pyproject.toml" ] || [ -f "setup.py" ]; then
    DETECTED_TYPE="python"
elif [ -f "Dockerfile" ]; then
    DETECTED_TYPE="docker"
fi
PROJECT_TYPE="${DETECTED_TYPE:-unknown}"
 
PROJECT_NAME=$(basename "$(pwd)")
log_project "$PROJECT_NAME" "$PROJECT_TYPE"
 
# =============================================================================
# OPTIMIZED JAVA PROJECT VALIDATION WITH COLORS
# =============================================================================
 
validate_java_project() {
    printf "${CYAN}${BOLD}‚òï [JAVA]${RESET} ${WHITE}Running comprehensive Java validation...${RESET}\n"
    
    local build_tool_found=false
    local java_compilation_success=false
    local build_tool_name=""
    
    # =============================================================================
    # BUILD TOOL DETECTION AND VALIDATION (Priority Order) - COLORIZED
    # =============================================================================
    
    # 1. MAVEN (Highest Priority - Most Enterprise)
    if [ -f "pom.xml" ] && command -v mvn >/dev/null 2>&1; then
        build_tool_found=true
        build_tool_name="Maven"
        MAVEN_VERSION=$(mvn --version 2>/dev/null | head -1 | sed 's/Apache Maven //' | cut -d' ' -f1)
        log_build_tool "Maven $MAVEN_VERSION"
        
        if [ "$TEST_MODE" = "true" ]; then
            # Test mode: validate POM syntax only
            log_debug "Validating Maven POM syntax..."
            if mvn help:effective-pom -q > /dev/null 2>&1; then
                java_compilation_success=true
            else
                log_error "Maven POM validation failed"
                return 1
            fi
        else
            # Production mode: full compilation
            printf "${BLUE}${BOLD}[INFO]${RESET} ${WHITE}Compiling Java sources with Maven...${RESET}\n"
            if mvn compile -q 2>/dev/null; then
                java_compilation_success=true
            else
                log_error "Maven compilation failed - run 'mvn compile' for details"
                return 1
            fi
        fi
    
    # 2. GRADLE (Second Priority - Modern Android/Spring)
    elif ([ -f "build.gradle" ] || [ -f "build.gradle.kts" ]); then
        build_tool_found=true
        build_tool_name="Gradle"
        
        # Prefer Gradle Wrapper over system Gradle
        if [ -f "gradlew" ]; then
            GRADLE_CMD="./gradlew"
            if [ -f "gradle/wrapper/gradle-wrapper.properties" ]; then
                GRADLE_VERSION=$(grep "distributionUrl" gradle/wrapper/gradle-wrapper.properties | sed -n 's/.*gradle-\([0-9.]*\)-.*/\1/p')
                log_build_tool "Gradle Wrapper $GRADLE_VERSION"
            else
                log_build_tool "Gradle Wrapper"
            fi
        elif command -v gradle >/dev/null 2>&1; then
            GRADLE_CMD="gradle"
            GRADLE_VERSION=$(gradle --version 2>/dev/null | grep "Gradle " | cut -d' ' -f2)
            log_build_tool "Gradle $GRADLE_VERSION"
        else
            log_error "Gradle build files found but no Gradle executable available"
            return 1
        fi
        
        if [ "$TEST_MODE" = "true" ]; then
            # Test mode: validate build files only
            log_debug "Validating Gradle build configuration..."
            if $GRADLE_CMD tasks --quiet > /dev/null 2>&1; then
                java_compilation_success=true
            else
                log_error "Gradle build validation failed"
                return 1
            fi
        else
            # Production mode: compile Java sources
            printf "${BLUE}${BOLD}[INFO]${RESET} ${WHITE}Compiling Java sources with Gradle...${RESET}\n"
            if $GRADLE_CMD compileJava --quiet 2>/dev/null; then
                java_compilation_success=true
            else
                log_error "Gradle compilation failed - run '$GRADLE_CMD compileJava' for details"
                return 1
            fi
        fi
    
    # 3. ANT (Legacy Enterprise)
    elif [ -f "build.xml" ] && command -v ant >/dev/null 2>&1; then
        build_tool_found=true
        build_tool_name="Ant"
        ANT_VERSION=$(ant -version 2>/dev/null | head -1 | cut -d' ' -f4)
        log_build_tool "Apache Ant $ANT_VERSION"
        
        if [ "$TEST_MODE" = "true" ]; then
            # Test mode: validate build.xml syntax
            log_debug "Validating Ant build configuration..."
            if ant -q -f build.xml -projecthelp > /dev/null 2>&1; then
                java_compilation_success=true
            else
                log_error "Ant build validation failed"
                return 1
            fi
        else
            # Production mode: compile if compile target exists
            if ant -q -f build.xml -projecthelp 2>/dev/null | grep -q "compile"; then
                printf "${BLUE}${BOLD}[INFO]${RESET} ${WHITE}Compiling Java sources with Ant...${RESET}\n"
                if ant compile -q 2>/dev/null; then
                    java_compilation_success=true
                else
                    log_error "Ant compilation failed - run 'ant compile' for details"
                    return 1
                fi
            else
                log_warning "No 'compile' target found in build.xml - skipping compilation"
                java_compilation_success=true
            fi
        fi
    
    # 4. FALLBACK: Raw javac (Simple Projects)
    elif command -v javac >/dev/null 2>&1; then
        build_tool_found=true
        build_tool_name="javac"
        JAVA_VERSION=$(javac -version 2>&1 | head -1 | cut -d' ' -f2)
        log_build_tool "javac $JAVA_VERSION (no build system)"
        
        # Find Java source files (performance optimized)
        if [ "$TEST_MODE" = "true" ]; then
            JAVA_FILES=$(find . -name "*.java" -not -path "./.git/*" | head -3)
        else
            # Production: only check staged Java files for performance
            JAVA_FILES=$(git diff --cached --name-only --diff-filter=ACM 2>/dev/null | grep '\.java$' | head -5)
        fi
        
        if [ -n "$JAVA_FILES" ]; then
            JAVA_COUNT=$(echo "$JAVA_FILES" | wc -l)
            printf "${BLUE}${BOLD}[INFO]${RESET} ${WHITE}Compiling $JAVA_COUNT Java source files...${RESET}\n"
            
            # Try to find classpath
            CLASSPATH="."
            [ -d "lib" ] && CLASSPATH="$CLASSPATH:lib/*"
            [ -d "target/classes" ] && CLASSPATH="$CLASSPATH:target/classes"
            [ -d "build/classes" ] && CLASSPATH="$CLASSPATH:build/classes"
            
            # Compile all files in one go for better performance
            if javac -cp "$CLASSPATH" -d /tmp $JAVA_FILES 2>/dev/null; then
                java_compilation_success=true
                # Clean up compiled classes
                rm -f /tmp/*.class 2>/dev/null
            else
                log_error "javac compilation failed"
                rm -f /tmp/*.class 2>/dev/null
                return 1
            fi
        else
            log_debug "No Java source files found to compile"
            java_compilation_success=true
        fi
    
    # 5. NO BUILD TOOL FOUND
    else
        log_warning "No recognized Java build tool found (Maven, Gradle, Ant, javac)"
        java_compilation_success=true  # Don't fail if we can't determine build system
    fi
    
    # =============================================================================
    # SINGLE SUCCESS MESSAGE - COLORIZED
    # =============================================================================
    
    if [ "$build_tool_found" = "true" ] && [ "$java_compilation_success" = "true" ]; then
        log_success "Java build validation completed ($build_tool_name)"
    elif [ "$java_compilation_success" = "false" ]; then
        return 1
    fi
    
    # =============================================================================
    # ADDITIONAL JAVA SECURITY CHECKS (COLORIZED)
    # =============================================================================
    
    # Security: Check for dangerous Runtime.exec usage (only if not in test mode)
    if [ "$TEST_MODE" != "true" ]; then
        log_debug "Checking for security violations..."
        
        # Combined security checks for better performance
        if find . -name "*.java" -path "*/src/main/*" 2>/dev/null | head -10 | xargs grep -l "Runtime\.getRuntime()\.exec\|ProcessBuilder" 2>/dev/null | grep -q .; then
            log_error "Security violation: Runtime.exec() or ProcessBuilder usage detected"
            return 1
        fi
        
        # Performance: Check for System.out.println in production code (optimized)
        PRINTLN_FILES=$(find . -name "*.java" -path "*/src/main/*" 2>/dev/null | head -10 | xargs grep -l "System\.out\.print\|System\.err\.print" 2>/dev/null)
        if [ -n "$PRINTLN_FILES" ]; then
            log_warning "System.out.println detected in production code - consider using proper logging"
            if [ "$VERBOSE" = "true" ]; then
                printf "${DIM}Files with System.out.println:${RESET}\n"
                echo "$PRINTLN_FILES" | head -3 | sed 's/^/  /'
            fi
        fi
    fi
    
    return 0
}
 
# =============================================================================
# OTHER PROJECT VALIDATIONS (Abbreviated for space - add colors similarly)
# =============================================================================
 
validate_dotnet_project() {
    printf "${PURPLE}${BOLD}üî∑ [.NET]${RESET} ${WHITE}Running .NET validation...${RESET}\n"
    
    if command -v dotnet >/dev/null 2>&1; then
        DOTNET_VERSION=$(dotnet --version 2>/dev/null)
        log_build_tool ".NET $DOTNET_VERSION"
        
        if [ "$TEST_MODE" = "true" ]; then
            log_debug "Validating .NET project configuration..."
            if dotnet build --no-restore --verbosity quiet --nologo 2>/dev/null; then
                log_success ".NET project validation completed"
            else
                log_error ".NET project validation failed"
                return 1
            fi
        else
            printf "${BLUE}${BOLD}[INFO]${RESET} ${WHITE}Running .NET formatting validation...${RESET}\n"
            if dotnet format --verify-no-changes --verbosity quiet 2>/dev/null; then
                log_success ".NET formatting validation completed"
            else
                log_error ".NET formatting validation failed - run 'dotnet format' to fix"
                return 1
            fi
            
            if grep -r "ConnectionStrings.*localhost" --include="*.json" --include="*.config" . 2>/dev/null; then
                log_error "Hardcoded connection strings detected"
                return 1
            fi
        fi
    else
        log_warning "dotnet CLI not available"
    fi
}
 
validate_nodejs_project() {
    printf "${GREEN}${BOLD}üì¶ [NODE.JS]${RESET} ${WHITE}Running Node.js validation...${RESET}\n"
    
    if command -v npm >/dev/null 2>&1; then
        NPM_VERSION=$(npm --version 2>/dev/null)
        log_build_tool "npm $NPM_VERSION"
        
        if [ -f "package.json" ] && [ ! -f "package-lock.json" ] && [ ! -f "yarn.lock" ]; then
            log_error "Package lock file required for dependency security"
            return 1
        fi
        
        if [ "$TEST_MODE" = "true" ]; then
            log_debug "Validating package.json syntax..."
            if node -e 'JSON.parse(require("fs").readFileSync("package.json"))' 2>/dev/null; then
                log_success "Node.js project validation completed"
            else
                log_error "package.json validation failed"
                return 1
            fi
        else
            if command -v npx >/dev/null 2>&1; then
                printf "${BLUE}${BOLD}[INFO]${RESET} ${WHITE}Running ESLint validation...${RESET}\n"
                if npx eslint . --max-warnings 0 2>/dev/null; then
                    log_success "ESLint validation completed"
                else
                    log_error "ESLint validation failed - fix linting issues"
                    return 1
                fi
                
                if [ -f "package-lock.json" ]; then
                    printf "${BLUE}${BOLD}[INFO]${RESET} ${WHITE}Running npm security audit...${RESET}\n"
                    if npm audit --audit-level moderate 2>/dev/null; then
                        log_success "npm security audit completed"
                    else
                        log_error "npm security audit failed - run 'npm audit fix'"
                        return 1
                    fi
                fi
            fi
        fi
    else
        log_warning "npm not available"
    fi
}
 
validate_python_project() {
    printf "${YELLOW}${BOLD}üêç [PYTHON]${RESET} ${WHITE}Running Python validation...${RESET}\n"
    
    if command -v python3 >/dev/null 2>&1; then
        PYTHON_VERSION=$(python3 --version 2>/dev/null | cut -d' ' -f2)
        log_build_tool "Python $PYTHON_VERSION"
        log_success "Python validation completed"
    else
        log_warning "python3 not available"
    fi
}
 
validate_docker_project() {
    printf "${BLUE}${BOLD}üê≥ [DOCKER]${RESET} ${WHITE}Running Docker validation...${RESET}\n"
    
    if command -v docker >/dev/null 2>&1; then
        DOCKER_VERSION=$(docker --version 2>/dev/null | cut -d' ' -f3 | sed 's/,//')
        log_build_tool "Docker $DOCKER_VERSION"
        log_success "Docker validation completed"
    else
        log_warning "docker not available"
    fi
}
 
# =============================================================================
# COLORIZED SECURITY VALIDATIONS
# =============================================================================
 
validate_security() {
    printf "${YELLOW}${BOLD}üîí [SECURITY]${RESET} ${WHITE}Running security validation...${RESET}\n"
    
    # Get staged files for performance
    STAGED_FILES=$(git diff --cached --name-only --diff-filter=ACM 2>/dev/null)
    
    if [ -n "$STAGED_FILES" ]; then
        STAGED_COUNT=$(echo "$STAGED_FILES" | wc -l)
        log_security_scan "Scanning $STAGED_COUNT staged files for secrets"
        
        # Secret scanning with mode-aware severity
        if echo "$STAGED_FILES" | xargs grep -iE "$SECURITY_PATTERNS" 2>/dev/null | grep -v "# " | grep -v "example" | grep -v "placeholder"; then
            if [ "$SECURITY_FAIL_ON_SECRETS" = "true" ]; then
                log_error "Hardcoded secrets detected in staged files"
                return 1
            else
                log_warning "Potential secrets detected (test mode - would fail in production)"
            fi
        fi
    else
        log_debug "No staged files to scan"
    fi
    
    # Large file detection
    if find . -type f -size +"$SECURITY_MAX_FILE_SIZE" -not -path "./.git/*" 2>/dev/null | grep -q .; then
        log_warning "Large files (>$SECURITY_MAX_FILE_SIZE) detected"
        if [ "$VERBOSE" = "true" ]; then
            printf "${DIM}Large files found:${RESET}\n"
            find . -type f -size +"$SECURITY_MAX_FILE_SIZE" -not -path "./.git/*" 2>/dev/null | head -5 | sed 's/^/  /'
        fi
    fi
    
    # Sensitive file detection
    SENSITIVE_FILES=".env .env.local .env.production id_rsa id_dsa *.pem *.key *.p12 *.pfx"
    for file in $SENSITIVE_FILES; do
        if find . -name "$file" -type f 2>/dev/null | grep -q .; then
            log_error "Sensitive file detected: $file"
            return 1
        fi
    done
    
    return 0
}
 
# =============================================================================
# MAIN EXECUTION FLOW
# =============================================================================
 
# Execute project-specific validations
case "$PROJECT_TYPE" in
    "java")
        validate_java_project
        ;;
    "dotnet")
        validate_dotnet_project
        ;;
    "nodejs")
        validate_nodejs_project
        ;;
    "python")
        validate_python_project
        ;;
    "docker")
        validate_docker_project
        ;;
    *)
        printf "${DIM}${BOLD}[GENERIC]${RESET} ${DIM}Generic validation for $PROJECT_TYPE project${RESET}\n"
        ;;
esac
 
# Execute security validations
validate_security
 
# =============================================================================
# COLORIZED FINAL SUMMARY
# =============================================================================
 
printf "\n"
printf "${BOLD}${BG_BLUE} üìä SUMMARY ${RESET} ${BOLD}Validation completed for ${CYAN}$PROJECT_TYPE${RESET}${BOLD} project:${RESET}\n"
 
if [ "$TEST_MODE" = "true" ]; then
    printf "   Mode: ${CYAN}${BOLD}üß™ TEST${RESET} ${CYAN}(non-blocking)${RESET}\n"
elif [ "$DRY_RUN" = "true" ]; then
    printf "   Mode: ${PURPLE}${BOLD}üîç DRY RUN${RESET} ${PURPLE}(simulation)${RESET}\n"
else
    printf "   Mode: ${GREEN}${BOLD}üöÄ PRODUCTION${RESET} ${GREEN}(enforced)${RESET}\n"
fi
 
case "$PROJECT_TYPE" in
    "java")
        printf "   ${GREEN}‚úÖ Java build validation (Maven/Gradle/Ant/javac)${RESET}\n"
        ;;
    "dotnet")
        printf "   ${GREEN}‚úÖ .NET formatting and security validation${RESET}\n"
        ;;
    "nodejs")
        printf "   ${GREEN}‚úÖ Node.js ESLint and security audit${RESET}\n"
        ;;
    "python")
        printf "   ${GREEN}‚úÖ Python syntax and formatting validation${RESET}\n"
        ;;
    "docker")
        printf "   ${GREEN}‚úÖ Docker security and best practices${RESET}\n"
        ;;
    *)
        printf "   ${GREEN}‚úÖ General security and file validation${RESET}\n"
        ;;
esac
 
printf "   ${GREEN}‚úÖ Security scanning (secrets, sensitive files)${RESET}\n"
printf "   ${GREEN}‚úÖ File size and performance checks${RESET}\n"
printf "   ${GREEN}‚úÖ Organizational policies enforced${RESET}\n"
 
if [ "$TEST_MODE" = "true" ]; then
    log_success "Test validation completed - no enforcement applied"
elif [ "$DRY_RUN" = "true" ]; then
    log_success "Dry run completed - would $([ "$FAIL_ON_ERROR" = "true" ] && echo "enforce policies" || echo "show warnings") in production"
else
    log_success "Production validation passed - organizational standards enforced"
fi
 
exit 0